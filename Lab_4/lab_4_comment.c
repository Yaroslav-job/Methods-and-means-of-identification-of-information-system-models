#include <mpi.h>      // Подключаем заголовочный файл библиотеки MPI (Message Passing Interface) для параллельных вычислений
#include <stdio.h>    // Подключаем стандартную библиотеку ввода-вывода (printf и др.)
#include <stdlib.h>   // Подключаем стандартную библиотеку (malloc, free и др.)
#include <time.h>     // Подключаем библиотеку для работы со временем (clock_gettime и структура timespec)

int main(int argc, char *argv[]) {  // Точка входа в программу, аргументы командной строки нужны для MPI_Init
    int rank;                       // Переменная для хранения номера процесса (ранга) в коммуникаторе
    struct timespec ts_start, ts_end; // Структуры для хранения времени начала и конца измерения

    MPI_Init(&argc, &argv);         // Инициализируем MPI, передаём аргументы командной строки
    MPI_Comm_rank(MPI_COMM_WORLD, &rank); // Получаем ранг (номер) текущего процесса в глобальном коммуникаторе MPI_COMM_WORLD

    long msg_size = 10;             // Начальный размер сообщения в байтах (10 байт)
    long max_size = 10L * 1024 * 1024; // Максимальный размер сообщения: 10 * 1024 * 1024 байт (10 МБ)

    if (rank == 0) {                // Действия только для процесса с рангом 0 (как "ведущий" процесс)
        printf("# size(bytes)\tt_one_way(sec)\n"); // Печатаем заголовок таблицы: размер сообщения и время в одну сторону
    }

    while (msg_size <= max_size) {  // Цикл по размерам сообщений: от начального до максимального включительно
        char *buffer = (char *)malloc(msg_size); // Выделяем динамическую память под буфер размером msg_size байт

        MPI_Barrier(MPI_COMM_WORLD); // Барьерная синхронизация: все процессы должны дойти до этого места перед продолжением

        if (rank == 0) {            // Код только для процесса 0
            clock_gettime(CLOCK_MONOTONIC, &ts_start); // Фиксируем время начала измерения (монотонные часы, не зависят от системных изменений времени)

            // Отправляем буфер процессу с рангом 1
            MPI_Send(buffer, (int)msg_size, MPI_BYTE, 1, 0, MPI_COMM_WORLD);
            // Получаем тот же буфер обратно от процесса 1
            MPI_Recv(buffer, (int)msg_size, MPI_BYTE, 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

            clock_gettime(CLOCK_MONOTONIC, &ts_end); // Фиксируем время окончания измерения

            // Вычисляем полное время "туда-обратно" в секундах:
            // разность секунд + разность наносекунд, переведённая в секунды
            double sec = (ts_end.tv_sec - ts_start.tv_sec) +
                         (ts_end.tv_nsec - ts_start.tv_nsec) / 1e9;

            // Время прохождения сообщения в одну сторону — половина времени "туда-обратно"
            double t_one_way = sec / 2.0;

            // Печатаем размер сообщения и измеренное время в одну сторону
            printf("%ld\t%g\n", msg_size, t_one_way);
        } else if (rank == 1) {     // Код только для процесса 1
            // Сначала принимаем сообщение от процесса 0
            MPI_Recv(buffer, (int)msg_size, MPI_BYTE, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            // Затем отправляем то же сообщение обратно процессу 0 (ответ "эхо")
            MPI_Send(buffer, (int)msg_size, MPI_BYTE, 0, 0, MPI_COMM_WORLD);
        }

        free(buffer);               // Освобождаем динамически выделенную память под буфер
        msg_size *= 8;              // Увеличиваем размер сообщения в 8 раз для следующей итерации цикла
    }

    MPI_Finalize();                 // Завершаем работу MPI, освобождаем ресурсы MPI
    return 0;                       // Возвращаем 0, сигнализируя об успешном завершении программы
}
